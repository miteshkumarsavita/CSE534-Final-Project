from Logger import Logger
import Filenames
import random
import hasher
from config import *

def inRangeExclusiveModulo(value, rangeStart, rangeEnd):
    if rangeStart < rangeEnd:
        return rangeStart < value and value < rangeEnd
    else:
        return not (rangeEnd <= value and value <= rangeStart)

def inRangeRightInclusiveModulo(value, rangeStart, rangeEnd):
    if rangeStart < rangeEnd:
        return rangeStart < value and value <= rangeEnd
    else:
        return not (rangeEnd < value and value <= rangeStart)

def rotateList(list, index):
    return list[-index:] + list[:-index]

class FingerTableEntry:
    def __init__(self, node, hashedVal):
        self.node = node
        self.hashedVal = hashedVal

class FingerTable:
    def __init__(self, nodes, selfNode):
        self.table = []
        self.selfHash = hasher.getHashChord(selfNode, chordSystemVarM)
        # rotate the list of nodes so that selfNode is at the head of the list
        nodes = rotateList(nodes, -1 * nodes.index(selfNode))
        
        for i in range(chordSystemVarM):
            node  = None #TODO: Mitesh
            self.table.append(FingerTableEntry(node, hasher.getHashChord(node, chordSystemVarM)))

    def getClosestPrecedingNode(self, val):
        # start from the end
        lookupHashedVal = hasher.getHashChord(val, chordSystemVarM)
        for i in range(len(self.table)-1, -1, -1):
            entry = self.table[i]
            if inRangeExclusiveModulo(entry.hashedVal, selfHash, lookupHashedVal):
                return entry.node
        return None # shouldn't happen? TODO:confirm

class ChordNode(process):
    def setup(config, nodes):
        self.name = "<ChordNode>"
        self.finished = False
        self.names = set()
        # rotate the list of nodes so that selfNode is at the head of the list
        nodes = rotateList(nodes, -1 * nodes.index(self))

        #TODO: save domainNames that belong to this node
        domainNamesFile = open(Filenames.getDomainNamesFilename(config), "rb")
        domainsStruct = pickle.load(domainNamesFile)
        domainNamesFile.close()
        domainNames = domainsStruct['domainNames']

        selfNodeHash = hasher.getHashChord(nodes[0], chordSystemVarM)
        predecessorNodeHash = hasher.getHashChord(nodes[-1], chordSystemVarM)
        for domainName in domainNames:
            hashedVal = hasher.getHashChord(domainName, chordSystemVarM)
            if inRangeRightInclusiveModulo(hashedVal, predecessorNodeHash, selfNodeHash):
                self.names.add(domainName)

        self.fingerTable = FingerTable(nodes, self)
        

    def run():
        await(self.finished)

class ChordDNS(process):
    def setup(config, master):
        self.master = master
        self.config = config
        self.name = "<ChordDNS>"
        self.logger = Logger(Filenames.getDNSLogFilename(config))
        self.logger.write(self.name + " setup")
        self.finished = False

        self.randomizer = random.Random()
        self.randomizer.seed(config['seedDNS'])

        self.nodes = list(new(ChordNode, num=config['nNodes']))
        self.nodes.sort(key=lambda obj : hasher.getHashChord(obj, chordSystemVarM))
        for node in self.nodes:
            setup(node, (config, self.nodes,))
            start(node)


    def run():
        self.logger.write(self.name + " running")
        await(self.finished)

    def receive(msg=('LOOKUP_QUERY', query,), from_= client):
        self.logger.write(self.name + " received ('LOOKUP_QUERY', " + str(query) + ",) from " + str(client))
        node = self.randomizer.choice(self.nodes)
        state  = 'NODE_LOOKUP_QUERY'
        #TODO: add self path
        self.logger.write(self.name + " sending ('" + state + "'," + str(query) + ") to " + str(node))
        send(('NODE_LOOKUP_QUERY', query,), to=node)
        return
        # TODO: move following code to wherever you get result
        state = 'LOOKUP_RESULT'
        self.logger.write(self.name + " sending ('" + state + "', " + str(query) + ",) to " + str(query['client']))
        send((state, query,), to=query['client'])

    def receive(msg=('GET_STATS',), from_= master):
        self.logger.write(self.name + " received ('GET_STATS',) from " + str(master))
        state = 'STATS_RESULT'
        stats = {'dummyValue':23}
        self.logger.write(self.name + " sending ('" + state + "',) to " + str(master))
        send((state, stats,), to=master)
        self.finished = True
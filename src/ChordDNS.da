from Logger import Logger
import Filenames
import random
import hasher
from config import *

class FingerTableEntry:
    def __init__(self, node, hashedVal):
        self.node = node
        self.hashedVal = hashedVal

class FingerTable:
    def __init__(self, nodes, selfNode):
        self.table = []
        
        # rotate the list of nodes so that node is at the head of the list
        nodes = rotate(nodes, -1 * nodes.index(selfNode))
        
        for i in range(chordSystemVarM):
            node  = None #TODO: Mitesh
            self.table.append(FingerTableEntry(node, hasher.getHashChord(node, chordSystemVarM)))

    def getClosestPrecedingNode(self, val):
        pass
        #TODO: shikhar
        
    def rotate(l, n):
        return l[-n:] + l[:-n]

class ChordNode(process):
    def setup(config, nodes):
        self.name = "<ChordNode>"
        self.finished = False
        self.fingerTable = FingerTable(nodes, self)
        
        domainNamesFile = open(Filenames.getDomainNamesFilename(config), "rb")
        domainsStruct = pickle.load(domainNamesFile)
        domainNamesFile.close()

        #TODO: save domainNames that belong to this node

    def run():
        await(self.finished)

class ChordDNS(process):
    def setup(config, master):
        self.master = master
        self.config = config
        self.name = "<ChordDNS>"
        self.logger = Logger(Filenames.getDNSLogFilename(config))
        self.logger.write(self.name + " setup")
        self.finished = False

        self.randomizer = random.Random()
        self.randomizer.seed(config['seedDNS'])

        self.nodes = list(new(ChordNode, num=config['nNodes']))
        self.nodes.sort(key=lambda obj : hasher.getHashChord(obj, chordSystemVarM))
        for node in self.nodes:
            setup(node, (config, self.nodes,))
            start(node)


    def run():
        self.logger.write(self.name + " running")
        await(self.finished)

    def receive(msg=('LOOKUP_QUERY', query,), from_= client):
        self.logger.write(self.name + " received ('LOOKUP_QUERY', " + str(query) + ",) from " + str(client))
        node = self.randomizer.choice(self.nodes)
        state  = 'NODE_LOOKUP_QUERY'
        #TODO: add self path
        self.logger.write(self.name + " sending ('" + state + "'," + str(query) + ") to " + str(node))
        send(('NODE_LOOKUP_QUERY', query,), to=node)
        return
        # TODO: move following code to wherever you get result
        state = 'LOOKUP_RESULT'
        self.logger.write(self.name + " sending ('" + state + "', " + str(query) + ",) to " + str(query['client']))
        send((state, query,), to=query['client'])

    def receive(msg=('GET_STATS',), from_= master):
        self.logger.write(self.name + " received ('GET_STATS',) from " + str(master))
        state = 'STATS_RESULT'
        stats = {'dummyValue':23}
        self.logger.write(self.name + " sending ('" + state + "',) to " + str(master))
        send((state, stats,), to=master)
        self.finished = True